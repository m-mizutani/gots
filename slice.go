package gots

// Map returns array of T2 generated by a set of return values of f.
func Map[T1, T2 any](input []T1, f func(T1) T2) []T2 {
	output := make([]T2, len(input))
	for i := range input {
		output[i] = f(input[i])
	}
	return output
}

// Filter returns slice of T consisting of input[] values
func Filter[T any](input []T, f func(T) bool) []T {
	var output []T
	for i := range input {
		if f(input[i]) {
			output = append(output, input[i])
		}
	}

	return output
}

// Reduce returns calculated one value of T by f with an initial value and input[].
func Reduce[T any](input []T, f func(prev T, current T) T, init T) T {
	c := init
	for i := range input {
		c = f(input[i], c)
	}
	return c
}

// Unique returns slice of unique values of input[]. A  returned slice order is stable (keeping original order of input[])
func Unique[T comparable](input []T) []T {
	var output []T
	added := map[T]struct{}{}
	for i := range input {
		if _, ok := added[input[i]]; ok {
			continue
		}
		output = append(output, input[i])
		added[input[i]] = struct{}{}
	}

	return output
}

// Count returns the number of values matched with target.
func Count[T comparable](input []T, target T) int {
	var c int
	for i := range input {
		if target == input[i] {
			c++
		}
	}
	return c
}

// CountIf returns the number of values checked by f.
func CountIf[T any](input []T, f func(v T) bool) int {
	var c int
	for i := range input {
		if f(input[i]) {
			c++
		}
	}
	return c
}

// Contains returns if there is a matched value with T in input[].
func Contains[T comparable](input []T, target T) bool {
	for i := range input {
		if target == input[i] {
			return true
		}
	}
	return false
}

// ToMap creates map[K]V from slice and func(T) (K, V)
func ToMap[T any, K comparable, V any](input []T, f func(T) (K, V)) map[K]V {
	resp := map[K]V{}

	for i := range input {
		k, v := f(input[i])
		resp[k] = v
	}

	return resp
}
